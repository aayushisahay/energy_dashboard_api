//deletet the another edcontext.cs we created              both are merged



//program.cs


using EnergyDashboardAPI1.Models;
using Microsoft.EntityFrameworkCore;

namespace EnergyDashboardAPI1
{
    public class Program
    {
        public static void Main(string[] args)
        {
            var builder = WebApplication.CreateBuilder(args);

            builder.Services.AddCors(options =>
            {
                options.AddPolicy("AllowAll", policy =>
                {
                    policy
                        .AllowAnyOrigin()
                        .AllowAnyHeader()
                        .AllowAnyMethod();
                });
            });

           


            builder.Services.AddControllers();
            builder.Services.AddDbContext<EnergyDbContext>(options =>
            options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));
            builder.Services.AddEndpointsApiExplorer();
            builder.Services.AddSwaggerGen();

            builder.Services.AddControllers()
            .AddJsonOptions(options =>
             {
                  options.JsonSerializerOptions.ReferenceHandler = System.Text.Json.Serialization.ReferenceHandler.IgnoreCycles;
                 options.JsonSerializerOptions.WriteIndented = true;
             });
            builder.Services.AddOpenApi();


            var app = builder.Build();
            if (app.Environment.IsDevelopment())
            {
                app.UseSwagger();
                app.UseSwaggerUI();
                app.UseCors("AllowAll");

                app.UseHttpsRedirection();
                app.UseAuthorization();
                app.MapControllers();
                app.Run();
            }
            ;

            if (app.Environment.IsDevelopment())
            {
                app.MapOpenApi();
            }

            app.UseMiddleware<ErrorHandlingMiddleware>();

            app.UseHttpsRedirection();

            app.UseAuthorization();


            app.MapControllers();

            app.Run();

        }
    }
}


//energydbcontext.cs

using System;
using System.Collections.Generic;
using Microsoft.EntityFrameworkCore;
using EnergyDashboardAPI1.Models;

namespace EnergyDashboardAPI1.Models
{
    public partial class EnergyDbContext : DbContext
    {
        public EnergyDbContext() { }

        public EnergyDbContext(DbContextOptions<EnergyDbContext> options)
            : base(options) { }

        public DbSet<Site> Sites { get; set; }
        public DbSet<User> Users { get; set; }
        public DbSet<Meter> Meters { get; set; }
        public DbSet<MeterReading> MeterReadings { get; set; }
        public DbSet<Space> Spaces { get; set; }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            if (!optionsBuilder.IsConfigured)
            {
                optionsBuilder.UseSqlServer("Server=DESKTOP-9E696H1\\SQLEXPRESS01;Database=EnergyDashboard;Trusted_Connection=True;TrustServerCertificate=True;");
            }
        }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Site>(entity =>
            {
                entity.HasKey(e => e.SiteId).HasName("PK__Sites__B9DCB903D8826677");
                entity.Property(e => e.SiteId).ValueGeneratedNever().HasColumnName("SiteID");
                entity.Property(e => e.SiteName).HasMaxLength(100);
                entity.Property(e => e.Address).HasMaxLength(200);
                entity.Property(e => e.ContactPerson).HasMaxLength(100);
                entity.Property(e => e.ContactEmail).HasMaxLength(100);
                entity.Property(e => e.ContactPhone).HasMaxLength(20);
                entity.Property(e => e.CreatedAt).HasColumnType("datetime").HasDefaultValueSql("(getdate())");
            });

            
            modelBuilder.Entity<User>(entity =>
            {
                entity.HasKey(e => e.UserId);
                entity.Property(e => e.Username).IsRequired().HasMaxLength(100);
                entity.Property(e => e.Password).IsRequired().HasMaxLength(100);
            });

            
            modelBuilder.Entity<Meter>(entity =>
            {
                entity.HasKey(e => e.MeterID).HasName("PK__Meters__59223B8CC59C0DFE");
                entity.Property(e => e.MeterID).HasColumnName("MeterID");
                entity.Property(e => e.MeterName).HasMaxLength(100).IsUnicode(false);
                entity.Property(e => e.SpaceId).HasColumnName("SpaceID");

                entity.HasOne(d => d.Space)
                      .WithMany(p => p.Meters)
                      .HasForeignKey(d => d.SpaceId)
                      .HasConstraintName("FK__Meters__SpaceID__3A81B327");
            });

            
            modelBuilder.Entity<MeterReading>(entity =>
            {
                entity.HasKey(e => new { e.MeterID, e.ReadingTimestamp });
                entity.Property(e => e.ReadingTimestamp).HasColumnType("datetime");
                entity.Property(e => e.Value).HasColumnName("Value");

                entity.HasOne(e => e.Meter)
                      .WithMany(m => m.MeterReadings)
                      .HasForeignKey(e => e.MeterID)
                      .HasConstraintName("FK_MeterReading_Meter");
            });

            
            modelBuilder.Entity<Space>(entity =>
            {
                entity.HasKey(e => e.SpaceId).HasName("PK__Spaces__83E25E0E28BAD6A3");
                entity.Property(e => e.SpaceId).HasColumnName("SpaceID");
                entity.Property(e => e.ParentSpaceId).HasColumnName("ParentSpaceID");
                entity.Property(e => e.SpaceName).HasMaxLength(100).IsUnicode(false);
                entity.Property(e => e.SpaceType).HasMaxLength(50).IsUnicode(false);

                entity.HasOne(d => d.ParentSpace)
                      .WithMany(p => p.InverseParentSpace)
                      .HasForeignKey(d => d.ParentSpaceId)
                      .HasConstraintName("FK__Spaces__ParentSp__37A5467C");
            });

            OnModelCreatingPartial(modelBuilder);
        }

        partial void OnModelCreatingPartial(ModelBuilder modelBuilder);
    }
}


//spaces.cs
using System;
using System.Collections.Generic;

namespace EnergyDashboardAPI1.Models;

public partial class Space
{
    public int SpaceId { get; set; }

    public int? ParentSpaceId { get; set; }

    public string? SpaceName { get; set; }

    public string? SpaceType { get; set; }

    public virtual ICollection<Space> InverseParentSpace { get; set; } = new List<Space>();

    public virtual ICollection<Meter> Meters { get; set; } = new List<Meter>();

    public virtual Space? ParentSpace { get; set; }
}


//meter.cs
using System;
using System.Collections.Generic;

namespace EnergyDashboardAPI1.Models;

public partial class Meter
{
    public int MeterID { get; set; }

    public int SpaceId { get; set; }

    public string? MeterName { get; set; }

    public virtual ICollection<MeterReading> MeterReadings { get; set; } = new List<MeterReading>();

    public virtual Space Space { get; set; }
}


//meterreading.cs
using System;
using System.ComponentModel.DataAnnotations.Schema;

namespace EnergyDashboardAPI1.Models
{
    public class MeterReading
    {
        public int MeterID { get; set; }
        public DateTime ReadingTimestamp { get; set; }

        public decimal Value { get; set; }

        public Meter Meter { get; set; }  
    }
}



//spacescontroller.cs
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using EnergyDashboardAPI1.Models;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace EnergyDashboardAPI1.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class SpacesController : ControllerBase
    {
        private readonly EnergyDbContext _context;

        public SpacesController(EnergyDbContext context)
        {
            _context = context;
        }

        [HttpGet]
        public async Task<ActionResult> GetSpaces()
        {
            try
            {
                var spaces = await _context.Spaces
                    .Select(s => new
                    {
                        s.SpaceId,
                        s.SpaceName
                    })
                    .ToListAsync();

                return Ok(spaces);
            }
            catch (Exception ex)
            {
                return StatusCode(500, "Error: " + ex.Message);
            }
        }
        [HttpGet("{id}/all-child-space-ids")]
        public async Task<ActionResult<List<int>>> GetAllChildSpaceIds(int id)
        {
            var allSpaces = await _context.Spaces.ToListAsync();

            List<int> result = new List<int> { id };
            Queue<int> queue = new Queue<int>();
            queue.Enqueue(id);

            while (queue.Count > 0)
            {
                int current = queue.Dequeue();
                var children = allSpaces
                    .Where(s => s.ParentSpaceId == current)
                    .Select(s => s.SpaceId)
                    .ToList();

                foreach (var child in children)
                {
                    result.Add(child);
                    queue.Enqueue(child);
                }
            }

            return result;
        }
    }
}


//metercontroller.cs
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using EnergyDashboardAPI1.Models;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace EnergyDashboardAPI1.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class MetersController : ControllerBase
    {
        private readonly EnergyDbContext _context;

        public MetersController(EnergyDbContext context)
        {
            _context = context;
        }

        [HttpGet]
        public async Task<ActionResult<IEnumerable<Meter>>> GetMeters()
        {
            return await _context.Meters.ToListAsync();
        }
    }
}


//meterreadingscontroller.cs
using EnergyDashboardAPI1.DTOs;
using EnergyDashboardAPI1.DTOs.EnergyDashboardAPI1.DTOs;
using EnergyDashboardAPI1.Models;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace EnergyDashboardAPI1.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class MeterReadingsController : ControllerBase
    {
        private readonly EnergyDbContext _context;

        public MeterReadingsController(EnergyDbContext context)
        {
            _context = context;
        }

        [HttpGet("meterreadings")]
        public async Task<IActionResult> GetMeterReadings(
    [FromQuery] int? spaceId = null,
    [FromQuery] DateTime? startTime = null,
    [FromQuery] DateTime? endTime = null)
        {
            try
            {
                IQueryable<MeterReading> query = _context.MeterReadings
                    .Include(mr => mr.Meter)
                    .ThenInclude(m => m.Space);

                if (spaceId.HasValue)
                {
                    query = query.Where(mr => mr.Meter.SpaceId == spaceId.Value);
                }
                if (startTime.HasValue)
                {
                    query = query.Where(mr => mr.ReadingTimestamp >= startTime.Value);
                }
                if (endTime.HasValue)
                {
                    query = query.Where(mr => mr.ReadingTimestamp <= endTime.Value);
                }

                var result = await query.ToListAsync();

                return Ok(result);
            }
            catch (Exception ex)
            {
                
                return StatusCode(500, new { message = "Internal server error", detail = ex.Message });
            }
        }

        [HttpGet("energy-consumption/{meterId}")]
        public async Task<IActionResult> GetEnergyConsumption(int meterId)
        {
            var readings = await _context.MeterReadings
                .Where(r => r.MeterID == meterId)
                .OrderBy(r => r.ReadingTimestamp)
                .ToListAsync();

            if (readings.Count < 2)
                return Ok("Not enough data to calculate consumption.");

            decimal totalConsumption = 0;

            for (int i = 1; i < readings.Count; i++)
            {
                var prev = readings[i - 1].Value;
                var curr = readings[i].Value;

                if (curr >= prev) 
                    totalConsumption += (curr - prev);
            }

            return Ok(new
            {
                MeterID = meterId,
                TotalEnergyConsumed = totalConsumption
            });
        }
        [HttpGet("energy-by-space/{spaceId}")]
        public async Task<ActionResult<IEnumerable<object>>> GetEnergyBySpace(int spaceId)
        {
            
            var allSpaces = await _context.Spaces.ToListAsync();

            
            List<int> childSpaceIds = new List<int> { spaceId };
            Queue<int> queue = new Queue<int>();
            queue.Enqueue(spaceId);

            while (queue.Count > 0)
            {
                int current = queue.Dequeue();
                var children = allSpaces
                    .Where(s => s.ParentSpaceId == current)
                    .Select(s => s.SpaceId)
                    .ToList();

                foreach (var child in children)
                {
                    childSpaceIds.Add(child);
                    queue.Enqueue(child);
                }
            }

            
            var readings = await _context.MeterReadings
                .Include(r => r.Meter)
                .Where(r => childSpaceIds.Contains(r.Meter.SpaceId))
                .OrderBy(r => r.MeterID)
                .ThenBy(r => r.ReadingTimestamp)
                .ToListAsync();

            
            var consumption = readings
                .GroupBy(r => r.MeterID)
                .Select(g => new
                {
                    MeterId = g.Key,
                    TotalEnergyConsumed = g
                        .OrderBy(r => r.ReadingTimestamp)
                        .Select((r, index) => index == 0 ? 0 : r.Value - g.ElementAt(index - 1).Value)
                        .Sum()
                });

            return Ok(consumption);
        }

        [HttpGet("energy-consumption-by-time")]
        public async Task<IActionResult> GetEnergyConsumptionByTime(DateTime startTime, DateTime endTime)
        {
            Console.WriteLine($"[DEBUG] StartTime: {startTime}, EndTime: {endTime}");

            var readings = await _context.MeterReadings
                .Where(r => r.ReadingTimestamp >= startTime && r.ReadingTimestamp <= endTime)
                .OrderBy(r => r.MeterID)
                .ThenBy(r => r.ReadingTimestamp)
                .ToListAsync();

            Console.WriteLine($"[DEBUG] Found {readings.Count} readings");

            return Ok(readings);
        }




           [HttpGet("energy-summary")]
    public async Task<IActionResult> GetEnergySummary(
        [FromQuery] List<int>? spaceIds,
        [FromQuery] DateTime startTime,
        [FromQuery] DateTime endTime)
    {
        if (startTime >= endTime)
        {
            return BadRequest(new ApiError
            {
                StatusCode = 400,
                Message = "Start time must be earlier than end time."
            });
        }

        if (spaceIds != null && spaceIds.Any(id => id <= 0))
        {
            return BadRequest(new ApiError
            {
                StatusCode = 400,
                Message = "All space IDs must be positive integers."
            });
        }

        var meterQuery = _context.Meters.AsQueryable();

        if (spaceIds != null && spaceIds.Any())
        {
            meterQuery = meterQuery.Where(m => spaceIds.Contains(m.SpaceId));
        }

        var meterIds = await meterQuery.Select(m => m.MeterID).ToListAsync();

        if (!meterIds.Any())
        {
            return NotFound(new ApiError
            {
                StatusCode = 404,
                Message = "No meters found for the given space IDs."
            });
        }

        var readings = await _context.MeterReadings
            .Where(r => meterIds.Contains(r.MeterID)
                     && r.ReadingTimestamp >= startTime
                     && r.ReadingTimestamp <= endTime)
            .OrderBy(r => r.ReadingTimestamp)
            .ToListAsync();

        if (readings.Count < 2)
        {
            return Ok(new
            {
                totalEnergyConsumption = 0,
                hourlyAggregated = new List<object>()
            });
        }

        var hourlyAggregated = readings
            .GroupBy(r => new
            {
                r.MeterID,
                Hour = r.ReadingTimestamp
                        .AddMinutes(-r.ReadingTimestamp.Minute)
                        .AddSeconds(-r.ReadingTimestamp.Second)
                        .AddMilliseconds(-r.ReadingTimestamp.Millisecond)
            })
            .Select(g => new
            {
                MeterId = g.Key.MeterID,
                Timestamp = g.Key.Hour,
                Reading = g.OrderBy(r => r.ReadingTimestamp).First().Value
            })
            .OrderBy(r => r.Timestamp)
            .ToList();

        var groupedList = hourlyAggregated
            .GroupBy(r => r.Timestamp)
            .OrderBy(g => g.Key)
            .ToList();

        var hourlyGrouped = groupedList
            .Select((group, index) =>
            {
                var previous = index > 0 ? groupedList[index - 1] : null;
                decimal totalDiff = 0;

                if (previous != null)
                {
                    foreach (var curr in group)
                    {
                        var prev = previous.FirstOrDefault(p => p.MeterId == curr.MeterId);
                        if (prev != null)
                        {
                            totalDiff += Math.Max(0, curr.Reading - prev.Reading);
                        }
                    }
                }

                return new
                {
                    timestamp = group.Key,
                    energyConsumed = Math.Round(totalDiff, 2)
                };
            })
            .Skip(1) 
            .ToList();

        var totalEnergy = Math.Round(hourlyGrouped.Sum(h => h.energyConsumed), 2);

        return Ok(new
        {
            totalEnergyConsumption = totalEnergy,
            hourlyAggregated = hourlyGrouped
        });
    }


    [HttpGet("space-wise-energy")]
    public async Task<IActionResult> GetSpaceWiseEnergy(
    [FromQuery] List<int>? spaceIds,
    [FromQuery] DateTime? startTime,
    [FromQuery] DateTime? endTime)
    {
        if (!startTime.HasValue || !endTime.HasValue)
        {
            return BadRequest(new ApiError
            {
                StatusCode = 400,
                Message = "Start time and end time are required."
            });
        }

        if (startTime >= endTime)
        {
            return BadRequest(new ApiError
            {
                StatusCode = 400,
                Message = "Start time must be earlier than end time."
            });
        }

        if (spaceIds != null && spaceIds.Any(id => id <= 0))
        {
            return BadRequest(new ApiError
            {
                StatusCode = 400,
                Message = "All space IDs must be positive integers."
            });
        }
        var meterQuery = _context.Meters.AsQueryable();

        if (spaceIds != null && spaceIds.Any())
        {
            meterQuery = meterQuery.Where(m => spaceIds.Contains(m.SpaceId));
        }

        var meterIds = await meterQuery.Select(m => m.MeterID).ToListAsync();

        if (!meterIds.Any())
        {
            return NotFound(new ApiError
            {
                StatusCode = 404,
                Message = "No meters found for the given space IDs."
            });
        }

        var readings = await _context.MeterReadings
            .Where(r => meterIds.Contains(r.MeterID) && r.ReadingTimestamp >= startTime && r.ReadingTimestamp <= endTime)
            .OrderBy(r => r.ReadingTimestamp)
            .ToListAsync();
        if (!readings.Any())
        {
            return NotFound(new ApiError
            {
                StatusCode = 404,
                Message = "No readings found for the given time range."
            });
        }


        var groupedReadings = readings
            .GroupBy(r => r.MeterID)
            .ToList();

        var spaceMeterMap = await _context.Meters
            .Where(m => meterIds.Contains(m.MeterID))
            .ToDictionaryAsync(m => m.MeterID, m => m.SpaceId);

        var totalBySpace = new Dictionary<int, decimal>();
        var hourlyBySpace = new Dictionary<int, Dictionary<DateTime, decimal>>();

        foreach (var meterGroup in groupedReadings)
        {
            var readingsList = meterGroup.OrderBy(r => r.ReadingTimestamp).ToList();
            for (int i = 1; i < readingsList.Count; i++)
            {
                var prev = readingsList[i - 1];
                var curr = readingsList[i];

                if (curr.ReadingTimestamp.Subtract(prev.ReadingTimestamp).TotalHours != 1)
                    continue;

                var diff = Math.Max(0, curr.Value - prev.Value);
                var hour = curr.ReadingTimestamp.AddMinutes(-curr.ReadingTimestamp.Minute).AddSeconds(-curr.ReadingTimestamp.Second).AddMilliseconds(-curr.ReadingTimestamp.Millisecond);
                if (!spaceMeterMap.TryGetValue(curr.MeterID, out var spaceId))
                    continue;

                if (!totalBySpace.ContainsKey(spaceId))
                    totalBySpace[spaceId] = 0;

                totalBySpace[spaceId] += diff;

                if (!hourlyBySpace.ContainsKey(spaceId))
                    hourlyBySpace[spaceId] = new Dictionary<DateTime, decimal>();

                if (!hourlyBySpace[spaceId].ContainsKey(hour))
                    hourlyBySpace[spaceId][hour] = 0;

                hourlyBySpace[spaceId][hour] += diff;
            }
        }

        var result = new
        {
            totalBySpace = totalBySpace.Select(kvp => new
            {
                spaceId = kvp.Key,
                energyConsumed = kvp.Value
            }),
            hourlyBySpace = hourlyBySpace.Select(kvp => new
            {
                spaceId = kvp.Key,
                hourly = kvp.Value.Select(h => new
                {
                    timestamp = h.Key,
                    energyConsumed = h.Value
                })
            })
        };

        return Ok(result);
    }

        [HttpGet("aggregated-summary")]
        public async Task<IActionResult> GetAggregatedSummary(
        [FromQuery] List<int> spaceIds,
        [FromQuery] DateTime startTime,
        [FromQuery] DateTime endTime,
        [FromQuery] string groupBy)
        {
            if (spaceIds == null || !spaceIds.Any())
                return BadRequest("Space IDs are required.");
            if (endTime <= startTime)
                return BadRequest("End time must be after start time.");

            var spaceMeterIds = await _context.Meters
                .Where(m => spaceIds.Contains(m.SpaceId))
                .Select(m => m.MeterID)
                .ToListAsync();

            var readings = await _context.MeterReadings
                .Where(r => spaceMeterIds.Contains(r.MeterID) &&
                            r.ReadingTimestamp >= startTime &&
                            r.ReadingTimestamp <= endTime)
                .OrderBy(r => r.ReadingTimestamp)
                .ToListAsync();

            var grouped = groupBy.ToLower() == "monthly"
            ? readings
           .GroupBy(r => new { r.ReadingTimestamp.Year, r.ReadingTimestamp.Month })
           .Select(g => new {
            Period = $"{g.Key.Year}-{g.Key.Month:D2}", 
            TotalEnergy = g.Max(x => x.Value) - g.Min(x => x.Value)
          })
    :       readings
           .GroupBy(r => r.ReadingTimestamp.Date)
           .Select(g => new {
            Period = g.Key.ToString("yyyy-MM-dd"), 
            TotalEnergy = g.Max(x => x.Value) - g.Min(x => x.Value)
        });


            return Ok(grouped);
        }


        [HttpGet("energy-aggregate")]
        public async Task<IActionResult> GetEnergyAggregate(
       [FromQuery] List<int> spaceIds,
       [FromQuery] DateTime startTime,
       [FromQuery] DateTime endTime)
        {
            if (spaceIds == null || !spaceIds.Any())
                return BadRequest("Space IDs are required.");
            if (endTime <= startTime)
                return BadRequest("End time must be after start time.");

            var meterIds = await _context.Meters
                .Where(m => spaceIds.Contains(m.SpaceId))
                .Select(m => m.MeterID)
                .ToListAsync();

            if (!meterIds.Any())
                return NotFound("No meters found for the given spaces.");

            var readings = await _context.MeterReadings
                .Where(r => meterIds.Contains(r.MeterID)
                            && r.ReadingTimestamp >= startTime
                            && r.ReadingTimestamp <= endTime)
                .OrderBy(r => r.ReadingTimestamp)
                .ToListAsync();

            if (!readings.Any())
                return NotFound("No readings found for the given criteria.");

            var totalEnergy = readings
                .GroupBy(r => r.MeterID)
                .Sum(g => g.Max(x => x.Value) - g.Min(x => x.Value));

            string aggregationLevel;
            var duration = (endTime - startTime).TotalDays;

            if (duration <= 2)
                aggregationLevel = "hourly";
            else if (duration <= 60)
                aggregationLevel = "daily";
            else
                aggregationLevel = "monthly";

            var aggregatedList = aggregationLevel switch
            {
                "hourly" => readings
                    .GroupBy(r => new { r.ReadingTimestamp.Date, r.ReadingTimestamp.Hour })
                    .Select(g => new {
                        Period = $"{g.Key.Date:yyyy-MM-dd} {g.Key.Hour:D2}:00",
                        TotalEnergy = g.Max(x => x.Value) - g.Min(x => x.Value)
                    }),

                "monthly" => readings
                    .GroupBy(r => new { r.ReadingTimestamp.Year, r.ReadingTimestamp.Month })
                    .Select(g => new {
                        Period = $"{g.Key.Year}-{g.Key.Month:D2}",
                        TotalEnergy = g.Max(x => x.Value) - g.Min(x => x.Value)
                    }),

                _ => readings
                    .GroupBy(r => r.ReadingTimestamp.Date)
                    .Select(g => new {
                        Period = g.Key.ToString("yyyy-MM-dd"),
                        TotalEnergy = g.Max(x => x.Value) - g.Min(x => x.Value)
                    })
            };

            return Ok(new
            {
                totalEnergy,
                aggregationLevel,
                aggregatedList
            });
        }

    }
}





//energyconsumptiondto.cs
namespace EnergyDashboardAPI1.DTOs
{
    namespace EnergyDashboardAPI1.DTOs
    {
        public class EnergyConsumptionDto
        {
            public int MeterID { get; set; }
            public DateTime ReadingTimestamp { get; set; }
            public decimal EnergyConsumed { get; set; }
        }
    }
}




//sitescontroller.cs
using EnergyDashboardAPI1.Models;
using Microsoft.EntityFrameworkCore;
using Microsoft.AspNetCore.Mvc;
using System.Threading.Tasks;

namespace EnergyDashboardAPI1.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class SitesController : ControllerBase
    {
        private readonly EnergyDbContext _context;

        public SitesController(EnergyDbContext context)
        {
            _context = context;
        }

        // POST: api/Sites
        [HttpPost]
        public async Task<IActionResult> PostSite([FromBody] Site site)
        {
            if (!ModelState.IsValid)
                return BadRequest(ModelState);

            _context.Sites.Add(site);
            await _context.SaveChangesAsync();

            return CreatedAtAction(nameof(GetSingleSite), new { id = site.SiteId }, site);
        }

        // GET: api/Sites/Single
        [HttpGet("Single")]
        public async Task<ActionResult<Site>> GetSingleSite()
        {
            var site = await _context.Sites.FirstOrDefaultAsync();

            if (site == null)
                return NotFound("No site data found.");

            return Ok(site);
        }

        // PUT: api/Sites/{id}
        [HttpPut("{id}")]
        public async Task<IActionResult> UpdateSite(int id, [FromBody] Site updatedSite)
        {
            if (id != updatedSite.SiteId)
                return BadRequest("ID mismatch.");

            var existingSite = await _context.Sites.FindAsync(id);
            if (existingSite == null)
                return NotFound("Site not found.");

            // Update fields
            existingSite.SiteName = updatedSite.SiteName;
            existingSite.Address = updatedSite.Address;
            existingSite.ContactPerson = updatedSite.ContactPerson;
            existingSite.ContactEmail = updatedSite.ContactEmail;
            existingSite.ContactPhone = updatedSite.ContactPhone;

            await _context.SaveChangesAsync();
            return NoContent();
        }
    }
}



//errorhandlingmiddleware.cs
using System.Text.Json;

public class ErrorHandlingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<ErrorHandlingMiddleware> _logger;

    public ErrorHandlingMiddleware(RequestDelegate next, ILogger<ErrorHandlingMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task Invoke(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unhandled exception occurred.");
            context.Response.StatusCode = 500;
            context.Response.ContentType = "application/json";

            var error = new ApiError
            {
                StatusCode = 500,
                Message = "An unexpected error occurred.",
                Details = ex.Message 
            };

            var json = JsonSerializer.Serialize(error);
            await context.Response.WriteAsync(json);
        }
    }

}




//apierror.cs
public class ApiError
{
    public int StatusCode { get; set; }
    public string Message { get; set; }
    public string? Details { get; set; } 
}





//user.cs
public class User
{
    public int UserId { get; set; }
    public string Username { get; set; }
    public string Password { get; set; }
}

//loginrequest.cs in dto folder
namespace EnergyDashboardAPI1.DTOs
{
    public class LoginRequest
    {
        public string Username { get; set; }
        public string Password { get; set; }
    }
}


//authcontroller
using EnergyDashboardAPI1.DTOs;
using EnergyDashboardAPI1.Models;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;

[Route("api/[controller]")]
[ApiController]
public class AuthController : ControllerBase
{
    private readonly EnergyDbContext _context;

    public AuthController(EnergyDbContext context)
    {
        _context = context;
    }

    [HttpPost("login")]
    public async Task<IActionResult> Login([FromBody] LoginRequest request)
    {
        if (string.IsNullOrEmpty(request.Username) || string.IsNullOrEmpty(request.Password))
            return BadRequest("Username and password are required.");

        var user = await _context.Users.FirstOrDefaultAsync(u => u.Username == request.Username);

        if (user == null)
            return Unauthorized("Username not found.");

        if (user.Password != request.Password)
            return Unauthorized("Incorrect password.");

        return Ok(new { message = "Login successful", user.Username });
    }
}
